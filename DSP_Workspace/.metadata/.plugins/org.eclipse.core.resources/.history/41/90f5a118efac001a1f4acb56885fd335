//#####################################################################
//  Chip: TMS320F28033
//  Freq: 60MHz (input osc. freq.:12MHz)
//  PWM
//
//#####################################################################
#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File
#include <stdio.h>
//
#define TX_En_Mux           GpioCtrlRegs.GPAMUX1.bit.GPIO1
#define TX_En_Dir           GpioCtrlRegs.GPADIR.bit.GPIO1
#define TX_En_Clr           GpioDataRegs.GPACLEAR.bit.GPIO1
#define TX_En_Set           GpioDataRegs.GPASET.bit.GPIO1
#define TX_En_Dat           GpioDataRegs.GPADAT.bit.GPIO1
//
#define TX_Sig_1_Mux        GpioCtrlRegs.GPAMUX1.bit.GPIO2  // EPWM2A
#define TX_Sig_1_Dir        GpioCtrlRegs.GPADIR.bit.GPIO2
#define TX_Sig_1_Clr        GpioDataRegs.GPACLEAR.bit.GPIO2
#define TX_Sig_1_Set        GpioDataRegs.GPASET.bit.GPIO2
#define TX_Sig_1_Dat        GpioDataRegs.GPADAT.bit.GPIO2
//
#define TX_Sig_2_Mux        GpioCtrlRegs.GPAMUX1.bit.GPIO3  // EPWM2B
#define TX_Sig_2_Dir        GpioCtrlRegs.GPADIR.bit.GPIO3
#define TX_Sig_2_Clr        GpioDataRegs.GPACLEAR.bit.GPIO3
#define TX_Sig_2_Set        GpioDataRegs.GPASET.bit.GPIO3
#define TX_Sig_2_Dat        GpioDataRegs.GPADAT.bit.GPIO3
//
//#define Toggle1_Mux         GpioCtrlRegs.GPAMUX2.bit.GPIO24 // An Auxiliary pin
//#define Toggle1_Dir         GpioCtrlRegs.GPADIR.bit.GPIO24
//#define Toggle1_Clr         GpioDataRegs.GPACLEAR.bit.GPIO24
//#define Toggle1_Set         GpioDataRegs.GPASET.bit.GPIO24
//#define Toggle1_Dat         GpioDataRegs.GPADAT.bit.GPIO24
//
#define     Ferrite_RxG_Max_L1    20    //30
#define     Ferrite_RXG_Min_L1    4 //6
#define     Ferrite_TxG_Max_L1    120   //160
#define     Ferrite_Min_No_of_Tag_L1  6
#define     Ferrite_Tag_Threshold_L1  400
#define     Ferrite_TxFreq_1_L1       F58_0
#define     Ferrite_TxFreq_2_L1       F58_0
#define     Ferrite_TxFreq_3_L1       F58_0
#define     Ferrite_TxFreq_4_L1       F58_0
#define     Ferrite_RxDur_L1          4  // *0.25ms
#define     Ferrite_TxDur_L1          10 // *0.1ms
//
//
#define     TxFreq_Center   517  // (30000/58)
#define     F60_0  500  // (30000/60)
////
#define     short_circuit_threshold 250
#define     Max_TX_Gap_Critical  400 // Min TX power Critical (in short cicuit sitiuation) //ok
#define     Max_TX_Gap  200 //280 // Min TX power //ok
//#define     Min_TX_Gap  40  //100  // Max TX power //ok
#define     TX_Tune_AGC_Threshold   1400    //1600 //chng_v1_2
#define FT_60_0  1000 //(60000/60.0)
//
#if(1) // function headers
void Initialize_Routine(void);
__interrupt void cpu_timer0_isr(void);
__interrupt void xint1_isr(void);
void Init_GPIOs(void);
void Init_PWM_Signals(void);
void Start_Over(void);
void Flush_Vectors(void);
void Main_Routine(void);
void Update_TX_Freq(Uint16 Period, Uint16 Gap);
void Disable_TX_Signal(void);
Uint16 ADC_TxTune(void);
void AGC_TX(void);
void Critical_Checks(void);
void Reset_Device(void);
#endif
//
        Uint16 TX_Freq_Counter = 0;
Uint16 TX_Pwr = 100;
Uint16 TX_Freq = TxFreq_Center;
Uint16 ADC_TxTune_Buffer[5][4];
Uint16 TX_Tune_instant;
Uint16 Tag_Label_mode;
Uint16 TxFreq_1, TxFreq_2, TxFreq_3, TxFreq_4;
Uint16 TxDuration, RxDuration;
Uint16 Tx_Tune_Value, TX_Tune_freq1, TX_Tune_freq2, TX_Tune_freq3,
        TX_Tune_freq4;
Uint16 Tune_counter, Tune_offset;
Uint16 PwmGap = Max_TX_Gap;
Uint16 TxGap_2 = Max_TX_Gap;
Uint16 TxGap_3 = Max_TX_Gap;
Uint16 TxGap_4 = Max_TX_Gap;
Uint16 TX_Gap = Max_TX_Gap;
Uint16 tune_offset_counter;
Uint16 TxTune_zero_offset[8];
Uint32 ADC_DC_Value_pin_1, ADC_DC_Value_pin_2;
Uint16 AGC_RX_Lagging;
Uint16 Periodic_init_counter;
Uint32 Turn_Off_Counter = 0;
Uint16 RxG_lvls_monitor_1, RxG_lvls_monitor_2, RxG_lvls_monitor_3,
        RxG_lvls_monitor_4, RxG_lvls_monitor_5, RxG_lvls_monitor_6,
        RxG_lvls_monitor_7, RxG_lvls_monitor_8, RxG_lvls_monitor_9,
        RxG_lvls_monitor_10, RxG_lvls_monitor_11;
Uint16 Test_freq = (60000 / 58);
Uint16 Ref_freq = (60000 / 70);
//Uint16 volatile PwmGap = 0;
#endif
//=================================//
void main(void)+
{
    Init_GPIOs();
    //
    memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t) &RamfuncsLoadSize);
    //
    InitSysCtrl(); // Step 1. Initialize System Control: PLL, WatchDog, enable Peripheral Clocks
    //
    DINT;
    // Disable CPU interrupt
    //
    InitFlash();
    //
    InitPieCtrl(); // Initialize the PIE control registers to their default state. The default state is all PIE interrupts disabled and flags are cleared.
    //
    IER = 0x0000;  // Disable CPU interrupts and clear all CPU interrupt flags:
    IFR = 0x0000;
    // Initialize the PIE vector table with pointers to the shell Interrupt
    // Service Routines (ISR).
    // This will populate the entire table, even if the interrupt
    // is not used in this example.  This is useful for debug purposes.
    // The shell ISR routines are found in DSP2803x_DefaultIsr.c.
    InitPieVectTable();
    //
    // Interrupts that are used in this example are re-mapped to
    // ISR functions found within this file.
    //
    Init_GPIOs();
    Init_ADC();
    Initialize_Routine();
    Init_PWM_Signals();
    Start_Over();
    ServiceDog();    // Reset the watchdog counter
    //
    EINT;
    // Enable Global interrupt INTM
    ERTM;
    // Enable Global realtime interrupt DBGM
    //
    //Wait_in_Error_mode();
    Main_Routine();
    for (;;);
}
//=================================//
void Initialize_Routine(void)
{
    // Enable Watchdog
    ServiceDog();    // Reset the watchdog counter
    EALLOW;
    SysCtrlRegs.SCSR = 0; //BIT1;
    SysCtrlRegs.WDCR = 0x002F; // WDCLK = OSCCLK/512/64
    //
    DINT;
    InitCpuTimers();   // For this example, only initialize the Cpu Timers
    CpuTimer0Regs.TCR.all = 0; // 0x4001; // Use write-only instruction
    CpuTimer0Regs.TCR.bit.TIE = 0;
    // External Interrupt: Zero Cross
    GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = ZC_pin_No;   // XINT1 is ZC
    // GpioIntRegs.GPIOXINT2SEL.bit.GPIOSEL = Slave_pulse_No;   // XINT2 is Slave-Pulse
    // Configure XINT1
    XIntruptRegs.XINT1CR.bit.POLARITY = 1; // Rising edge (0:Falling edge, 1:Rising edge, 3:both edge)
    // XIntruptRegs.XINT2CR.bit.POLARITY = 0;      // Falling edge (0:Falling edge, 1:Rising edge, 3:both edge)
    // Enable XINT1
    XIntruptRegs.XINT1CR.bit.ENABLE = 1;        // Enable XINT1
    //    XIntruptRegs.XINT2CR.bit.ENABLE = 1;        // Enable XINT2
    // Interrupts that are used in this example are re-mapped to
    // ISR functions found within this file.
    PieVectTable.XINT1 = &xint1_isr;    // Zero-Cross-Pulse
    //PieVectTable.XINT2 = &xint2_isr;   // Slave-Sync-Pulse
    PieVectTable.TINT0 = &cpu_timer0_isr;
    EDIS;
    // This is needed to disable write to EALLOW protected registers
    //
    // Enable XINT1 and XINT2 and TINT0 in the PIE: Group 1 interrupt 4 & 5 &7
    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;    // Enable the PIE block
    PieCtrlRegs.PIEIER1.bit.INTx4 = 1; // XINT1(Zero-Cross-Pulse)      // Enable PIE Group 1 INT4
    //PieCtrlRegs.PIEIER1.bit.INTx5 = 1;  // XINT2(Slave-Sync-Pulse)      // Enable PIE Group 1 INT5
    PieCtrlRegs.PIEIER1.bit.INTx7 = 1; // TINT0 (Timer0)   // Enable PIE Group 1 INT7
    IER |= M_INT1;                        // Enable CPU INT1
    DINT;
    // Initialize I2C
    I2caRegs.I2CSAR = 0x0050;        // Slave address - EEPROM control code
    I2caRegs.I2CPSC.all = 6;         // Prescaler - need 7-12 Mhz on module clk
    I2caRegs.I2CCLKL = 10;           // NOTE: must be non zero
    I2caRegs.I2CCLKH = 5;            // NOTE: must be non zero
    //        I2caRegs.I2CIER.all = 0x24; // 0x24;      // Enable SCD & ARDY interrupts
    I2caRegs.I2CMDR.all = 0x0020;    // Take I2C out of reset
    // Stop I2C when suspended
    // I2caRegs.I2CFFTX.all = 0x6000;   // Enable FIFO mode and TXFIFO
    // I2caRegs.I2CFFRX.all = 0x2040;   // Enable RXFIFO, clear RXFFINT,
    // Sens_Shadow = EEPROM_Read(Sens_key_eeprom_addr);
    //
    Sync_index = 0;
    //
    Uint16 EEPROM_Sign_value;
    DELAY_US(20000);
    EEPROM_Sign_value = EEPROM_Read(Signature_eeprom_Addr);
    DELAY_US(20000);
    if (EEPROM_Sign_value != AM_RxTx_V5_0_Signature)
    {
        ServiceDog();
        DELAY_US(20000);
        I2C_Result_Write = EEPROM_Write(Sens_key_eeprom_addr,
                                        Sens_default_value);
        DELAY_US(20000);
        I2C_Result_Write = EEPROM_Write(Sync_key_eeprom_addr,
                                        Sync_default_value);
        DELAY_US(20000);
        //I2C_Result_Write = EEPROM_Write(Sync_index_eeprom_addr, 0);
        //DELAY_US(20000);
        I2C_Result_Write = EEPROM_Write(Signature_eeprom_Addr,
                                        AM_RxTx_V5_0_Signature);
        DELAY_US(20000);
    }
}
//============================================//
void Init_GPIOs(void)
{
    // Configure GPIOs:
    EALLOW;
    ///////
    TX_En_Mux = 0;
    TX_En_Dir = 1;
    TX_En_Set = 1;
    //
    Toggle1_Mux = 0;
    Toggle1_Dir = 1;
    Toggle1_Clr = 1;
    //
    TX_Sig_1_Mux = 0;
    TX_Sig_1_Dir = 1;
    TX_Sig_1_Clr = 1;
    //
    TX_Sig_2_Mux = 0;
    TX_Sig_2_Dir = 1;
    TX_Sig_2_Clr = 1;
    //
    EDIS;
}
//==============================================//
#pragma CODE_SECTION(Init_PWM_Signals, "ramfuncs");
void Init_PWM_Signals(void)
{
    // TX signals:
    EALLOW;
    //TX_Sig_1_Mux = 1;   // Configure GPIO2 as EPWM2A: TX_signal1
    //TX_Sig_2_Mux = 1;   // Configure GPIO3 as EPWM2A: TX_signal2
    //
    EPwm2Regs.TBPRD = 517; // Period = * TBCLK counts
    EPwm2Regs.CMPA.half.CMPA = 317; // Compare A TBCLK counts
    EPwm2Regs.CMPB = 200; // Compare B TBCLK counts
    EPwm2Regs.TBPHS.half.TBPHS = 0; // Set Phase register to zero
    EPwm2Regs.TBPHS.all = 0; // Set Phase register to zero //chng_v1_2
    EPwm2Regs.TBCTR = 0; // clear TB counter
    EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;
    EPwm2Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Phase loading disabled
    EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW;
    EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;
    EPwm2Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1; // TBCLK = SYSCLKOUT
    EPwm2Regs.TBCTL.bit.CLKDIV = TB_DIV1;
    EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // load on TBCTR = Zero
    EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; // load on TBCTR = Zero
    EPwm2Regs.AQCTLA.bit.CAU = AQ_SET;
    EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR;
    EPwm2Regs.AQCTLB.bit.CBU = AQ_CLEAR;
    EPwm2Regs.AQCTLB.bit.CBD = AQ_SET;
    //
    EDIS;
}
//===============================================//
//#pragma CODE_SECTION(Start_Over, "ramfuncs");
void Start_Over(void)
{
    Uint16 temp1;
    DINT;
    // Turn off Timer_2.5ms:
    CpuTimer0Regs.TCR.bit.TIE = 0;
    CpuTimer0Regs.TCR.bit.TSS = 1;
    CpuTimer0Regs.TCR.bit.TIF = 1;
    //
    //
    TX_En_Set = 1;
    Tx_Tune_Value = 0;
    TX_Tune_freq1 = 0;  //chng_v1_2
    TX_Tune_freq2 = 0;  //chng_v1_2
    TX_Tune_freq3 = 0;  //chng_v1_2
    TX_Tune_freq4 = 0;  //chng_v1_2
    Tune_counter = 0;   //chng_v1_2
    Tune_offset = 0;    //chng_v1_2
    TX_Tune_instant = 2500; //chng_v1_2
    //
    TX_Freq = TxFreq_Center;
    TX_Gap = 200;
    Status_Counter = 0;
    TX_Freq_Counter = 0;
    //
    ServiceDog();    // Reset the watchdog counter
    //
    //
    Sync_changing_handle();
    ////////////////////
        Flush_Vectors();
    //
    PwmGap = Max_TX_Gap;    // Min Gain

}
//============================================//
void Reset_Device(void)
{
    DINT;
    EALLOW;
    SysCtrlRegs.WDCR = 0x0047; // a wrong value in order to reset device
    EDIS;
}
//=============================================//
#pragma CODE_SECTION(Flush_Vectors, "ramfuncs");
void Flush_Vectors(void)
{
    Uint16 index, i;
    //
    for (index = 0; index < 5; index++)
    {
        for (i = 0; i < 4; i++)
        {
            ADC_TxTune_Buffer[index][i] = 0;
        }
    }
    //
    for (index = 0; index < 8; index++)
    {
        TxTune_zero_offset[index] = 0;
    }
    //
}
//============================================//
//=================================//
//=================================//
#pragma CODE_SECTION(Main_Routine, "ramfuncs");
void Main_Routine(void)
{
    Uint16 PreTX_delay = 1;
    Uint16 del;
    //
    while (1)
    {
        Update_TX_Freq(TX_Freq, TX_Gap);  //chng_v1_2
        DELAY_US(100); // Added
        TX_En_Clr = 1;
        TX_En_Set = 1;
        Disable_TX_Signal();
        //
        DELAY_US(100);
        ADC_TxTune();
        DELAY_US(150);
        AGC_TX();
        ServiceDog();    // Reset the watchdog counter
        //
        //
    } // End of While loop
}
//============================================//
/*#pragma CODE_SECTION(xint1_isr,"ramfuncs");
__interrupt void xint1_isr(void)
{
        // Enable Timer_2.5ms:
        CpuTimer0Regs.TIM.all = 0;
        CpuTimer0Regs.PRD.all = (Uint32) (150000);  //2.5msec
        CpuTimer0Regs.TCR.bit.TRB = 1; // Reload timer0
        CpuTimer0Regs.TCR.bit.TSS = 0; // Start Timer0
        CpuTimer0Regs.TCR.bit.TIE = 1; // Enable timer interrupt
        //
    // Acknowledge this interrupt to get more from group 1
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}*/
//============================================//
#pragma CODE_SECTION(cpu_timer0_isr,"ramfuncs");
__interrupt void cpu_timer0_isr(void)
{
    // stop timer0 , no further count
    CpuTimer0Regs.TCR.bit.TIE = 0;
    CpuTimer0Regs.TCR.bit.TSS = 1;

    ////////////////////////////
    CpuTimer0Regs.TCR.bit.TIF = 1;
    CpuTimer0.InterruptCount++;
    // Acknowledge this interrupt to receive more interrupts from group 1
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
//============================================//
#pragma CODE_SECTION(Update_TX_Freq, "ramfuncs");
void Update_TX_Freq(Uint16 Period, Uint16 Gap)
{
    if (Gap < 40)
    {
        Err_pin_Set = 1;
        Gap = 200;
        PwmGap = 0x0080;
    }
    if (Period < 500)
    {
        Err_pin_Set = 1;
        Period = 500;
        PwmGap = 0x0080;
    }
    // Period = 30000/TX_Freq
    Uint16 CompA, CompB;
    CompA = Period + Gap;
    CompA = (CompA >> 1);
    CompB = Period - Gap;
    CompB = (CompB >> 1);
    EALLOW;
    EPwm2Regs.TBPRD = Period;  //517; // Period = * TBCLK counts
    EPwm2Regs.CMPA.half.CMPA = CompA; //317; // Compare A TBCLK counts
    EPwm2Regs.CMPB = CompB; // Compare B TBCLK counts
    //EPwm2Regs.TBCTR = 0; // clear TB counter //chng_v1_2

    //
    TX_Sig_1_Mux = 1;   // Configure as EPWM2A: TX_signal1
    TX_Sig_2_Mux = 1;   // Configure as EPWM2A: TX_signal2
    //
    EDIS;
}
//===============================================//
#pragma CODE_SECTION(Disable_TX_Signal, "ramfuncs");
void Disable_TX_Signal(void)
{
    EALLOW;
    TX_Sig_1_Mux = 0;
    TX_Sig_1_Dir = 1;
    TX_Sig_1_Clr = 1;
    TX_Sig_2_Mux = 0;
    TX_Sig_2_Dir = 1;
    TX_Sig_2_Clr = 1;
    EDIS;
}
//===============================================//
#pragma CODE_SECTION(ADC_TxTune, "ramfuncs");
Uint16 ADC_TxTune(void)
{
    AdcRegs.ADCINTFLGCLR.bit.ADCINT3 = 1;
    AdcRegs.ADCSOCFRC1.bit.SOC2 = 1;
    while (AdcRegs.ADCINTFLG.bit.ADCINT3 == 0){}
    AdcRegs.ADCINTFLGCLR.bit.ADCINT3 = 1;
    TX_Tune_instant = AdcResult.ADCRESULT2;
    return TX_Tune_instant;
}
//===============================================//
#pragma CODE_SECTION(Pwr_Avrager, "ramfuncs");
void Pwr_Avrager(Uint 16 state)
{
    Uint16 k, temp1;
    Tune_counter++;
    if (Tune_counter >= 4)
    {
        Tune_counter = 0;
    }
    if (state == 0)
    {
        TxTune_zero_offset[Tune_counter] = TX_Tune_instant;
        temp1 = 0;
        for (k = 0; k < 4; k++)
        {
            temp1 += TxTune_zero_offset[k];
        }
        temp1 = (temp1 >> 2);
        Tune_offset = temp1;
    }
    else
    {
        if (TX_Tune_instant < Tune_offset)
        {
            ADC_TxTune_Buffer[Tune_counter] = Tune_offset - TX_Tune_instant;
        }
        else
        {
            ADC_TxTune_Buffer[Tune_counter] = 0;
        }
        for (k = 0; k < 4; k++)
        {
            temp1 += ADC_TxTune_Buffer[k];
        }
        Tx_Tune_Value = (temp1 >> 2);
    }


}

#pragma CODE_SECTION(AGC_TX, "ramfuncs");
void AGC_TX(void)
{
    Uint16 k, temp1;
    //
    if (Jam_Scan_Status == 1)
    {
        tune_offset_counter++;
        if (tune_offset_counter >= 8)
        {
            tune_offset_counter = 0;
        }
        TxTune_zero_offset[tune_offset_counter] = TX_Tune_instant;
        temp1 = 0;
        for (k = 0; k < 8; k++)
        {
            temp1 += TxTune_zero_offset[k];
        }
        temp1 = (temp1 >> 3);
        Tune_offset = temp1;
    }
    else
    {
        Tune_counter++;
        if (Tune_counter >= 4)
        {
            Tune_counter = 0;
        }
        if (TX_Tune_instant < Tune_offset)
        {
            ADC_TxTune_Buffer[Tune_counter] = Tune_offset - TX_Tune_instant;
        }
        else
        {
            ADC_TxTune_Buffer[Tune_counter] = 0;
        }
        /////////////////////
        temp1 = ADC_TxTune_Buffer[0] + ADC_TxTune_Buffer[1]
                + ADC_TxTune_Buffer[2] + ADC_TxTune_Buffer[3];
        Tx_Tune_Value = (temp1 >> 2);
        //
        ////////////////////////
        if (Tune_counter == 3)
        {
            if (Tx_Tune_Value > TX_Tune_AGC_Threshold)
            {
                PwmGap++;
            }
            else
            {
                PwmGap--;
            }
            if (PwmGap > Max_TX_Gap)
            {
                PwmGap = Max_TX_Gap;
            } // Min Gain
            if (PwmGap < TX_Pwr)
            {
                PwmGap = TX_Pwr;
            }   // Max Gain
            //
                   //
        }
    }

    //////////////////////////
    if (TX_Tune_instant < short_circuit_threshold)   // short-circuit condition
    {
        Err_pin_Set = 1;
        PwmGap = Max_TX_Gap_Critical;
        TxGap_2 = Max_TX_Gap_Critical;
        TxGap_3 = Max_TX_Gap_Critical;
        TxGap_4 = Max_TX_Gap_Critical;
        Reset_Device(); //chng_v1_2
    }
    //
    // Bypass AGC_TX:
    /*    if (Boot_pin_Dat == 0)
     {
     TxGap_1 = TX_Pwr;   //Min_TX_Gap;    // Max Gain
     TxGap_2 = TX_Pwr;   //Min_TX_Gap;    // Max Gain
     TxGap_3 = TX_Pwr;   //Min_TX_Gap;    // Max Gain
     TxGap_4 = TX_Pwr;   //Min_TX_Gap;    // Max Gain
     }
     */
}
//============================================//


